/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useRef } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useThree, useFrame } from "@react-three/fiber";

import { useStore } from "../store";

type GLTFResult = GLTF & {
    nodes: {
        Alpha_Joints: THREE.SkinnedMesh;
        Alpha_Surface: THREE.SkinnedMesh;
        mixamorigHips: THREE.Bone;
    };
    materials: {
        Alpha_Joints_MAT: THREE.MeshStandardMaterial;
        Alpha_Body_MAT: THREE.MeshStandardMaterial;
    };
};

type ActionName = "tpose";
type GLTFActions = Record<ActionName, THREE.AnimationAction>;

const modelPath = "/models/glb/ybot.glb";
const animationPath = "/models/glb/animations";

type Props = {
    animation: string;
};
export function Ybot_with_Animation(props: JSX.IntrinsicElements["group"]) {
    const [editor, playerConfig] = useStore((state) => [
        state.editor,
        state.playerConfig,
    ]);
    const { cameraDistance, animationNames } = playerConfig;
    const { camera } = useThree();

    // const group = useRef<THREE.Group>();
    const { nodes, materials, animations } = useGLTF(modelPath) as GLTFResult;

    const animationClips: THREE.AnimationClip[] = [];
    animationClips.push(...animations);
    animationNames.forEach((name) => {
        const { animations } = useGLTF(animationPath + `/${name}.glb`);
        animationClips.push(...animations);
    });
    const { actions, ref } = useAnimations(animationClips);

    // const { actions } = useAnimations<GLTFActions>(animations, group);

    useFrame(() => {
        if (!editor) {
            // const cameraDirection = new THREE.Vector3();
            // camera.getWorldDirection(cameraDirection);
            // cameraDirection.normalize();
            // cameraDirection.setLength(cameraDistance);
            // cameraDirection.add(camera.position);
            // nodes.Alpha_Joints.skeleton.bones[4].lookAt(cameraDirection);
            nodes.Alpha_Joints.skeleton.bones[4].rotation.copy(camera.rotation);
        }
    });

    return (
        <group ref={ref} {...props} dispose={null}>
            <group name="Scene">
                <group
                    name="Armature"
                    rotation={[Math.PI / 2, 0, 0]}
                    scale={0.01}
                >
                    <primitive object={nodes.mixamorigHips} />
                    <skinnedMesh
                        name="Alpha_Joints"
                        geometry={nodes.Alpha_Joints.geometry}
                        material={materials.Alpha_Joints_MAT}
                        skeleton={nodes.Alpha_Joints.skeleton}
                    />
                    <skinnedMesh
                        name="Alpha_Surface"
                        geometry={nodes.Alpha_Surface.geometry}
                        material={materials.Alpha_Body_MAT}
                        skeleton={nodes.Alpha_Surface.skeleton}
                    />
                </group>
            </group>
        </group>
    );
}

useGLTF.preload(modelPath);
